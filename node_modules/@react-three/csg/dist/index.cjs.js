'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var THREE = require('three');
var React = require('react');
var fiber = require('@react-three/fiber');
var CSG = require('three-bvh-csg');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var CSG__namespace = /*#__PURE__*/_interopNamespace(CSG);

const context = /*#__PURE__*/React.createContext(null);
const Brush = /*#__PURE__*/React.forwardRef(({
  a,
  b,
  children,
  ...props
}, fref) => {
  fiber.extend({
    Brush: CSG__namespace.Brush
  });
  const refBrush = React.useRef(null);
  const parent = React.useContext(context);
  React.useLayoutEffect(() => {
    var _refBrush$current$geo;

    // If this brush does not have geometry directly traverse it
    if (!refBrush.current.geometry || !((_refBrush$current$geo = refBrush.current.geometry.attributes) != null && _refBrush$current$geo.position)) {
      let brush = null;
      refBrush.current.traverse(obj => obj !== refBrush.current && obj instanceof CSG__namespace.Brush && (brush = obj));
      if (brush) refBrush.current.geometry = brush.geometry;
    } // Subscribe to the operation above


    if (parent && (a || b)) {
      parent.slots[a ? 0 : 1] = refBrush.current;
    }
  }, []);
  const mounted = React.useRef(false);
  React.useEffect(() => {
    if (mounted.current && parent) parent.update(true);
  });
  React.useEffect(() => {
    mounted.current = true;
  }, []);
  fiber.useFrame(() => {
    if (parent && refBrush.current.needsUpdate) {
      refBrush.current.needsUpdate = false;
      parent.update(true);
    }
  });
  React.useImperativeHandle(fref, () => refBrush.current, []);
  return /*#__PURE__*/React__default["default"].createElement("brush", _extends__default["default"]({
    ref: refBrush,
    geometry: undefined
  }, props), children);
});
const Operation = /*#__PURE__*/React.forwardRef(({
  a,
  b,
  children,
  op,
  useGroups = false,
  ...props
}, fref) => {
  fiber.extend({
    Brush: CSG__namespace.Brush
  });
  const parent = React.useContext(context);
  const refBrush = React.useRef(null);
  const refGeom = React.useRef(null);
  const [target] = React.useState(() => new CSG__namespace.Brush());
  const [csgEvaluator] = React.useState(() => new CSG__namespace.Evaluator());
  const [slots] = React.useState([null, null]);
  const api = React.useMemo(() => ({
    parent,
    slots,
    update: force => {
      const nodeA = slots[0];
      const nodeB = slots[1];

      if (nodeA && nodeB && refBrush.current) {
        refBrush.current.matrixWorld.identity();
        nodeA.updateMatrixWorld();
        nodeB.updateMatrixWorld();
        csgEvaluator.useGroups = useGroups;

        function dispose(geometry) {
          geometry.attributes = {};
          geometry.groups = [];
          geometry.boundingBox = null;
          geometry.boundingSphere = null;
          geometry.drawRange = {
            start: 0,
            count: Infinity
          };
          geometry.dispose();
        }

        try {
          if (target.geometry) {
            // Dispose previous geometry
            dispose(target.geometry);
            if (!parent) dispose(refGeom.current);
            target.geometry = new THREE__namespace.BufferGeometry();
          }

          const result = csgEvaluator.evaluate(nodeA, nodeB, op, target);
          const geometry = result.geometry;

          if (parent) {
            refBrush.current.geometry = geometry;
            if (csgEvaluator.useGroups) refBrush.current.material = result.material;
          } else {
            var _refGeom$current, _refGeom$current$__r;

            // Overwrite the higher up meshs material to use material groups
            if (csgEvaluator.useGroups && (_refGeom$current = refGeom.current) != null && (_refGeom$current$__r = _refGeom$current.__r3f) != null && _refGeom$current$__r.parent) refGeom.current.__r3f.parent.material = result.material;
            refGeom.current.attributes = geometry.attributes;
            refGeom.current.groups = geometry.groups;
            refGeom.current.drawRange = geometry.drawRange;
          }
        } catch (e) {
          console.log(e);
        }

        if (force) {
          let cur = parent;

          while (cur) {
            cur.update();
            cur = cur.parent;
          }
        }
      }
    }
  }), [parent, useGroups]);
  React.useLayoutEffect(() => {
    // If an operation above this one exists, make this one act as a brush and subscribe to the op
    if (parent && (a || b)) {
      parent.slots[a ? 0 : 1] = refBrush.current;
    }

    api.update(true);
  }, [api]);
  fiber.useFrame(() => {
    if (refBrush.current.needsUpdate) {
      refBrush.current.needsUpdate = false;
      api.update(true);
    }
  });
  React.useImperativeHandle(fref, () => refBrush.current, []);
  return /*#__PURE__*/React__default["default"].createElement(context.Provider, {
    value: api
  }, /*#__PURE__*/React__default["default"].createElement("bufferGeometry", {
    ref: refGeom
  }, /*#__PURE__*/React__default["default"].createElement("brush", _extends__default["default"]({
    ref: refBrush
  }, props), children)));
});
const Subtraction = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React__default["default"].createElement(Operation, _extends__default["default"]({}, props, {
  ref: fref,
  op: CSG__namespace.SUBTRACTION
})));
const Addition = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React__default["default"].createElement(Operation, _extends__default["default"]({}, props, {
  ref: fref,
  op: CSG__namespace.ADDITION
})));
const Difference = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React__default["default"].createElement(Operation, _extends__default["default"]({}, props, {
  ref: fref,
  op: CSG__namespace.DIFFERENCE
})));
const Intersection = /*#__PURE__*/React.forwardRef((props, fref) => /*#__PURE__*/React__default["default"].createElement(Operation, _extends__default["default"]({}, props, {
  ref: fref,
  op: CSG__namespace.INTERSECTION
})));

exports.Addition = Addition;
exports.Brush = Brush;
exports.Difference = Difference;
exports.Intersection = Intersection;
exports.Subtraction = Subtraction;
