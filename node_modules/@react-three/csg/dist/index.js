import _extends from '@babel/runtime/helpers/esm/extends';
import * as THREE from 'three';
import React, { forwardRef, useRef, useContext, useLayoutEffect, useEffect, useImperativeHandle, createContext, useState, useMemo } from 'react';
import { extend, useFrame } from '@react-three/fiber';
import * as CSG from 'three-bvh-csg';

const context = /*#__PURE__*/createContext(null);
const Brush = /*#__PURE__*/forwardRef(({
  a,
  b,
  children,
  ...props
}, fref) => {
  extend({
    Brush: CSG.Brush
  });
  const refBrush = useRef(null);
  const parent = useContext(context);
  useLayoutEffect(() => {
    var _refBrush$current$geo;

    // If this brush does not have geometry directly traverse it
    if (!refBrush.current.geometry || !((_refBrush$current$geo = refBrush.current.geometry.attributes) != null && _refBrush$current$geo.position)) {
      let brush = null;
      refBrush.current.traverse(obj => obj !== refBrush.current && obj instanceof CSG.Brush && (brush = obj));
      if (brush) refBrush.current.geometry = brush.geometry;
    } // Subscribe to the operation above


    if (parent && (a || b)) {
      parent.slots[a ? 0 : 1] = refBrush.current;
    }
  }, []);
  const mounted = useRef(false);
  useEffect(() => {
    if (mounted.current && parent) parent.update(true);
  });
  useEffect(() => {
    mounted.current = true;
  }, []);
  useFrame(() => {
    if (parent && refBrush.current.needsUpdate) {
      refBrush.current.needsUpdate = false;
      parent.update(true);
    }
  });
  useImperativeHandle(fref, () => refBrush.current, []);
  return /*#__PURE__*/React.createElement("brush", _extends({
    ref: refBrush,
    geometry: undefined
  }, props), children);
});
const Operation = /*#__PURE__*/forwardRef(({
  a,
  b,
  children,
  op,
  useGroups = false,
  ...props
}, fref) => {
  extend({
    Brush: CSG.Brush
  });
  const parent = useContext(context);
  const refBrush = useRef(null);
  const refGeom = useRef(null);
  const [target] = useState(() => new CSG.Brush());
  const [csgEvaluator] = useState(() => new CSG.Evaluator());
  const [slots] = useState([null, null]);
  const api = useMemo(() => ({
    parent,
    slots,
    update: force => {
      const nodeA = slots[0];
      const nodeB = slots[1];

      if (nodeA && nodeB && refBrush.current) {
        refBrush.current.matrixWorld.identity();
        nodeA.updateMatrixWorld();
        nodeB.updateMatrixWorld();
        csgEvaluator.useGroups = useGroups;

        function dispose(geometry) {
          geometry.attributes = {};
          geometry.groups = [];
          geometry.boundingBox = null;
          geometry.boundingSphere = null;
          geometry.drawRange = {
            start: 0,
            count: Infinity
          };
          geometry.dispose();
        }

        try {
          if (target.geometry) {
            // Dispose previous geometry
            dispose(target.geometry);
            if (!parent) dispose(refGeom.current);
            target.geometry = new THREE.BufferGeometry();
          }

          const result = csgEvaluator.evaluate(nodeA, nodeB, op, target);
          const geometry = result.geometry;

          if (parent) {
            refBrush.current.geometry = geometry;
            if (csgEvaluator.useGroups) refBrush.current.material = result.material;
          } else {
            var _refGeom$current, _refGeom$current$__r;

            // Overwrite the higher up meshs material to use material groups
            if (csgEvaluator.useGroups && (_refGeom$current = refGeom.current) != null && (_refGeom$current$__r = _refGeom$current.__r3f) != null && _refGeom$current$__r.parent) refGeom.current.__r3f.parent.material = result.material;
            refGeom.current.attributes = geometry.attributes;
            refGeom.current.groups = geometry.groups;
            refGeom.current.drawRange = geometry.drawRange;
          }
        } catch (e) {
          console.log(e);
        }

        if (force) {
          let cur = parent;

          while (cur) {
            cur.update();
            cur = cur.parent;
          }
        }
      }
    }
  }), [parent, useGroups]);
  useLayoutEffect(() => {
    // If an operation above this one exists, make this one act as a brush and subscribe to the op
    if (parent && (a || b)) {
      parent.slots[a ? 0 : 1] = refBrush.current;
    }

    api.update(true);
  }, [api]);
  useFrame(() => {
    if (refBrush.current.needsUpdate) {
      refBrush.current.needsUpdate = false;
      api.update(true);
    }
  });
  useImperativeHandle(fref, () => refBrush.current, []);
  return /*#__PURE__*/React.createElement(context.Provider, {
    value: api
  }, /*#__PURE__*/React.createElement("bufferGeometry", {
    ref: refGeom
  }, /*#__PURE__*/React.createElement("brush", _extends({
    ref: refBrush
  }, props), children)));
});
const Subtraction = /*#__PURE__*/forwardRef((props, fref) => /*#__PURE__*/React.createElement(Operation, _extends({}, props, {
  ref: fref,
  op: CSG.SUBTRACTION
})));
const Addition = /*#__PURE__*/forwardRef((props, fref) => /*#__PURE__*/React.createElement(Operation, _extends({}, props, {
  ref: fref,
  op: CSG.ADDITION
})));
const Difference = /*#__PURE__*/forwardRef((props, fref) => /*#__PURE__*/React.createElement(Operation, _extends({}, props, {
  ref: fref,
  op: CSG.DIFFERENCE
})));
const Intersection = /*#__PURE__*/forwardRef((props, fref) => /*#__PURE__*/React.createElement(Operation, _extends({}, props, {
  ref: fref,
  op: CSG.INTERSECTION
})));

export { Addition, Brush, Difference, Intersection, Subtraction };
